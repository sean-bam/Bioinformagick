#!/usr/bin/perl5.16

############################################################
#	Template:	1.1, August 17, 2015
#	Parent Path:	/home/wolf/bin on frosty
############################################################

############################################################
#	System etc
############################################################
use lib "/home/wolf/perl5/lib/perl5";
use YIW::basic;
use YIW::tree;

our $Pver = "0.11";
our $Pdat = "September 09 2020";

our ($Pnam) = ($0 =~ m/([^\/]+)$/);
our ($Path) = ($0 =~ m/^(.+)\/[^\/]+$/);$Path = "." unless($Path);

our $Ppid = $$;	# Process ID

our $Base = "";
our $Basd = "";
while(1){
 my $r1 = 1 + int(rand(0x7ffffffd));
 my $r2 = 1 + int(rand(9998));
 $Basd = join ".",("d",$r1);
 $Base = join ".",("t",$r2);
 last unless(-e $Basd);
}
our $CMD = "";
############################################################
#	Definitions
############################################################
$db = "nr";
$long_seqids = "-long_seqids";
$target = "";
$hh_sge = "-sge";
$cthr = 0.5;
$word = 2;
$nmax = 1000;
$dthr = 1.2;
$mthr = 0.05;
$lthr = 0.667;
$name = "test";
$preclean = 0;
$imax = 3;
$alimode = 0;
$hhsmode = 0;
$gcut = 0.667;
$forcenew = 0;
$DEBUG = 0;

############################################################
#	Global variables
############################################################
@glst;
@cls1;
$ncls = 0;

############################################################
#	Instructions etc
############################################################
$Instructions = <<EOINPUT;

$Path/$Pnam $Pver, $Pdat

Use: $Pnam gilist [options]

Preclusters sequences; runs HHSEARCH on profiles; bulds UPGMA tree;
aligns related profiles with HHALIGN.

Produces:	$name.*.sr
		$name.cls
		$name.up.tre

Options:

	-ali		list of existing sr alignment files (default GIs)

	-db=db		database to extract sequences (default $db)

	-ncbi		db is an NCBI db (default no)

	-bare		"bare IDs" in db (default prefixed)

	-w=n		use n-th word of ID (default $word; 0 - all)

	-n=name		output name (default $name)

	-c=x		MMCLUST threshold for 1st pass clustering (default $cthr)

	-m=n		report <=n HMM hits (default $nmax)

	-hhs		save the last HHSEARCH result in $name.hhs.out

	-l=x		length threshold for cluster comparison (default $lthr)

	-u=x		UPGMA depth threshold for cluster comparison (default $dthr)

	-gcut=x		remove position with >x gaps at all iterations (default $gcut)

	-pure		DISABLED pre-purify intermediate alignments (default no)

	-i=n		perform <=n iterations (default $imax)

	-forcenew	forecefully make output even if no new alignments

	-nosge		do not send HHSEARCH to SGE

Requirements:

	Wolf scripts
	BLAST
	MMSEQ2; MUSCLE
	MAFFT
	HHALIGN, HHSEARCH
	R
	SGE
EOINPUT

############################################################
#	code start
############################################################

#---	get and process arguments --------------------------
YIW::basic::my_args(\@ARGV,1);					# pass 0 to block STDIN
!@myGlobList and print $Instructions and exit 0;

# examples for using options:
# $opts = 1 if(exists $myOptList{"q"});				# on/off
# $opti = int $myOptList{"i"} if(int $myOptList{"i"}>0);	# positive integer
# $opti = $myOptList{"x"} + 0 if($myOptList{"x"}>0);		# positive real
# $optl = $myOptList{"l"} if($myOptList{"l"} ne "");		# non-empty string

$DEBUG = 1 if(exists $myOptList{"DEBUG"});
$forcenew = 1 if(exists $myOptList{"forcenew"});
$alimode = 1 if(exists $myOptList{"ali"});
$hhsmode = 1 if(exists $myOptList{"hhs"});
$db = $myOptList{"d"} if($myOptList{"d"} ne "");		# alternative flag
$db = $myOptList{"db"} if($myOptList{"db"} ne "");
$long_seqids = "" if(exists $myOptList{"bare"});
$target = "-target_only" if(exists $myOptList{"ncbi"});
$name = $myOptList{"n"} if($myOptList{"n"} ne "");
$word = $myOptList{"w"} if($myOptList{"w"} ne "");		# int as string!
$nmax = int $myOptList{"m"} if(int $myOptList{"m"}>0);
$cthr = $myOptList{"c"} + 0 if($myOptList{"c"}>0);
$lthr = $myOptList{"l"} + 0 if($myOptList{"l"}>0);
$dthr = $myOptList{"u"} + 0 if($myOptList{"u"}>0);
$mthr = $myOptList{"s"} + 0 if($myOptList{"s"}>0);
$gcut = $myOptList{"gcut"} + 0 if($myOptList{"gcut"}>0);
#@@#$preclean = 1 if(exists $myOptList{"pure"});
$imax = int $myOptList{"i"} if(int $myOptList{"i"}>0);
$hh_sge = "" if(exists $myOptList{"nosge"});

my $flst = shift @myGlobList;

#---	rest of the code -----------------------------------
# $CMD = ""; print STDERR "$Pnam:\t[ $CMD ]\n"; system $CMD;
#
# print STDERR "$Pnam:\tReading $dlst/$core.$clst\n";
# open HAND,"<$dlst/$core.$clst" or die "$Pnam:\tCan't read \"$dlst/$core.$clst\"";
# while(<HAND>){
#  chomp;
# }
# close HAND;
# printf STDERR "$Pnam:\t\t%s\tgenomes\n",int_commify(scalar @glist);

#---	read the list --------------------------------------
print STDERR "$Pnam:\tReading $flst\n";
open HAND,"<$flst" or die "$Pnam:\tCan't read \"$flst\"";
while(<HAND>){
 chomp;
 my ($gi) = split/\s+/;
 push @glst,$gi;;
}
close HAND;
printf STDERR "$Pnam:\t\t%s\tGIs\n",int_commify(scalar @glst);

#---	adjust $Base ---------------------------------------
#while(glob("$Base.*")){
# my $tmp = 1 + int(rand(0x7ffffffd));
# $Base = "t.$tmp";
#}

	#$Base = "t.5138";	#@@#
	#if(0){	#@@#

#---	prepare $Base --------------------------------------
mkdir $Basd;

####	start with raw sequences ###########################
if($alimode==0){
#---	save the list --------------------------------------
 open HAND,">$Basd/$Base.gi" or die "$Pnam:\tCan't read \"$Basd/$Base.gi\"";
 foreach my $gi (@glst){
  print HAND "$gi\n";
 }
 close HAND;

#---	get sequences --------------------------------------
 $CMD = "blastdbcmd -db $db -entry_batch $Basd/$Base.gi $target $long_seqids -out $Basd/$Base.fa"; print STDERR "$Pnam:\t[ $CMD ]\n"; system $CMD;

#---	cluster sequences ----------------------------------
 #$CMD = "run_uclust -s= $cthr -w=$word $Basd/$Base.fa > $Basd/$Base.0.cls"; print STDERR "$Pnam:\t[ $CMD ]\n"; system $CMD;
 $CMD = "run_mmclust -s= $cthr -w=$word $Basd/$Base.fa > $Basd/$Base.0.cls"; print STDERR "$Pnam:\t[ $CMD ]\n"; system $CMD;

	#}	#@@#

#---	read clusters --------------------------------------
 print STDERR "$Pnam:\tReading $Basd/$Base.0.cls\n";
 open HAND,"<$Basd/$Base.0.cls" or die "$Pnam:\tCan't read \"$Basd/$Base.0.cls\"";
 while(<HAND>){
  chomp;
  my ($nn,$list) = split/\t/;
  my @clst = split/\s+/,$list;
  push @cls1,\@clst;
 }
 close HAND;
 $ncls = @cls1;
 printf STDERR "$Pnam:\t\t%s\tclusters\n",int_commify($ncls);

	#if(0){	#@@#

#---	align clusters -------------------------------------
 {
 my $bflag = ""; $bflag = "-bare" if($long_seqids eq "");
 my $sflag = $hh_sge; $sflag = "" if($ncls<100);
 my $nflag = ""; $nflag = "-ncbi" if($target ne "");
 $CMD = "cls2ali -d= $db $bflag $nflag -a= $Basd/$Base.1 -sing $sflag $Basd/$Base.0.cls"; print STDERR "$Pnam:\t[ $CMD ]\n"; system $CMD;
 }

#---	format alignments ----------------------------------
 for(my $i=0;$i<$ncls;$i++){
  my $n = $i + 1;
  $CMD = "fa2sr $Basd/$Base.1.$n.afa -w=$word > $Basd/$Base.1.$n.sr"; print STDERR "$Pnam:\t[ $CMD ]\n"; system $CMD;
 }
####	start with existing alignments #####################
}else{
 $ncls = @glst;
 for(my $i=0;$i<$ncls;$i++){
  my $n = $i + 1;
  my $fali = $glst[$i];
  $CMD = "cp $fali $Basd/$Base.1.$n.sr"; print STDERR "$Pnam:\t[ $CMD ]\n"; system $CMD;
  my @clst;
  open HAND,"<$Basd/$Base.1.$n.sr" or die "$Pnam:\tCan't read \"$Basd/$Base.1.$n.sr\"";
  while(<HAND>){
   chomp;
   my ($gi) = split/\s+/;
   push @clst,$gi;
  }
  close HAND;
  push @cls1,\@clst;
 }
}
####	endif ##############################################

#---	clean alignments -----------------------------------
if($preclean){
 for(my $i=0;$i<$ncls;$i++){
  my $n = $i + 1;
  $CMD = "sr_scoreMatch $Basd/$Base.1.$n.sr | tab_select -k1=1 -kcut= $mthr > $Basd/$Base.1.$n.tab ; tab_select $Basd/$Base.1.$n.sr -t= $Basd/$Base.1.$n.tab -k2=2 > $Basd/$Base.1.$n.tmp ; sr_filter $Basd/$Base.1.$n.tmp -grcut= 0.999999 > $Basd/$Base.1.$n.sr"; print STDERR "$Pnam:\t[ $CMD ]\n"; system $CMD;
 }
}

unlink <$Basd/$Base.1.*.afa>;
unlink <$Basd/$Base.1.*.tmp>;
unlink <$Basd/$Base.1.*.tab>;

	#}	#@@#
	#if(0){	#@@#

#---	prepare to iterate ---------------------------------
my $doit = 1;
my $lfrom = 1;
my $lto = 2;
my $nt = $ncls;

#---	list clusters --------------------------------------
open HAND,">$Basd/$Base.$lfrom.lst" or die "$Pnam:\tCan't write \"$Basd/$Base.$lfrom.lst\"";
for(my $i=0;$i<$ncls;$i++){
 printf HAND "$Basd/$Base.$lfrom.%d.sr\n",$i+1;
}
close HAND;

#---	ITERATE --------------------------------------------
while($doit){
 $doit = 0;

#---	check if any work is needed ------------------------
 if($nt==1){
  #$CMD = "tab_shuffle $Base.$lfrom.1.sr -l=1 -f= \"%s;\" > $Base.$lfrom.up.tre"; print STDERR "$Pnam:\t[ $CMD ]\n"; system $CMD;
  open HAND,">$Basd/$Base.$lfrom.up.tre" or die "$Pnam:\tCan't write \"$Basd/$Base.$lfrom.up.tre\"";
  printf HAND "$Base.$lfrom.1;\n";
  close HAND;
  $lfrom++;
  $lto++;
  last;
 }

#---	prep for comparison (gaps) -------------------------
if($gcut<1){
 for(my $i=1;$i<=$nt;$i++){
  $CMD = "mv $Basd/$Base.$lfrom.$i.sr $Basd/$Base.$lfrom.$i.sx ; sr_filter $Basd/$Base.$lfrom.$i.sx -grcut= $gcut > $Basd/$Base.$lfrom.$i.sr"; print STDERR "$Pnam:\t[ $CMD ]\n"; system $CMD;
 }
}

#---	compare clusters -----------------------------------
 my $nrep = $nt; $nrep = $nmax if($nrep>$nmax);
 $CMD = "run_hhsearch $Basd/$Base.$lfrom.lst -d= . -n= $Basd/$Base.$lfrom.tmp -z= $nrep -pre $hh_sge > $Basd/$Base.$lfrom.hhs.out"; print STDERR "$Pnam:\t[ $CMD ]\n"; system $CMD;
 unlink <$Basd/$Base.$lfrom.tmp.*>;
 if($hhsmode){
  $CMD = "cp $Basd/$Base.$lfrom.hhs.out $Basd/$Base.hhs.out"; print STDERR "$Pnam:\t[ $CMD ]\n"; system $CMD;
 }

#---	restore after comparison (gaps) --------------------
if($gcut<1){
 for(my $i=1;$i<=$nt;$i++){
  $CMD = "mv $Basd/$Base.$lfrom.$i.sx $Basd/$Base.$lfrom.$i.sr"; print STDERR "$Pnam:\t[ $CMD ]\n"; system $CMD;
 }
}

#---	tree of clusters -----------------------------------
 $CMD = "hhres2dis_mat $Basd/$Base.$lfrom.hhs.out -n=3 -s=1 -d=2 -o=2 -l= $lthr | run_R_hclust > $Basd/$Base.$lfrom.up.tre"; print STDERR "$Pnam:\t[ $CMD ]\n"; system $CMD;

#---	alignable subtrees ---------------------------------
 $CMD = "tree_tips -d= $dthr $Basd/$Base.$lfrom.up.tre -w=2 -s > $Basd/$Base.$lfrom.mul.tre"; print STDERR "$Pnam:\t[ $CMD ]\n"; system $CMD;

 if($lto>$imax){
  $lfrom++;
  $lto++;
  last;
 }

#---	align clusters -------------------------------------
 $nt = 0;
 open HANX,">$Basd/$Base.$lto.lst" or die "$Pnam:\tCan't write \"$Basd/$Base.$lto.lst\"";
 print STDERR "$Pnam:\tReading $Basd/$Base.$lfrom.mul.tre\n";
 open HAND,"<$Basd/$Base.$lfrom.mul.tre" or die "$Pnam:\tCan't read \"$Basd/$Base.$lfrom.mul.tre\"";
 while(<HAND>){
  $nt++;
  chomp;
  my ($ns) = m/^\[(\d+)/;
  open HANY,">$Basd/$Base.$lto.$nt.tre" or die "$Pnam:\tCan't write \"$Basd/$Base.$lto.$nt.tre\"";
  print HANY "$_\n";
  close HANY;
  $doit = 1 if($ns>1);
  $CMD = "hh_guided_align $Basd/$Base.$lto.$nt.tre -d= $Basd -gcut= $gcut > $Basd/$Base.$lto.$nt.sr"; print STDERR "$Pnam:\t[ $CMD ]\n"; system $CMD;
  print HANX "$Basd/$Base.$lto.$nt.sr\n";
 }
 close HAND;
 printf STDERR "$Pnam:\t#%d\t%s\talignments\n",$lfrom,int_commify($nt);
 close HANX;
 if($doit){
  unlink <$Basd/$Base.$lfrom.*.sr> unless($DEBUG);
 }else{
  unlink <$Basd/$Base.$lto.*.sr> unless($DEBUG);
 }
 unlink <$Basd/$Base.$lto.*.tre> unless($DEBUG);
 $lfrom++;
 $lto++;
}
$lfrom--;
$lto--;

	#}	#@@#
	#$lfrom=3;	#@@#
	#$nt=208;	#@@#

#---	restore original clusters --------------------------
if($preclean){
 my %gi2cl = ();
 for(my $i=0;$i<$ncls;$i++){
  my $n = $i + 1;
  my $rlst = $cls1[$i];
  foreach my $gi (@$rlst){ $gi2cl{$gi} = $n;}
 }
 for(my $i=1;$i<$nt;$i++){
  my %gset = ();
  open HAND,"<$Basd/$Base.$lfrom.$i.sr" or die "$Pnam:\tCan't read \"$Basd/$Base.$lfrom.$i.sr\"";
  while(<HAND>){
   chomp;
   my ($gi) = split/\s+/;
   $gset{$gi} = 1;
  }
  close HAND;
  my %cset = ();
  foreach my $gi (keys %gset){
   $cset{$gi2cl{$gi}} = 1;
  }
  my %gadd = ();
  foreach my $cl (keys %cset){
   my $rlst = $cls1[$cl-1];
   foreach my $gi (@$rlst){
    $gadd{$gi} = 1 if($gset{$gi} eq "");
   }
  }
  next if((scalar keys %gadd)<=0);			# not cleaned
  printf STDERR "$Pnam:\tadd\t%d\tgis to cluster #%d\n",(scalar keys %gadd),$i;
  my $pref = "";
  for(my $j=1;$j<$word;$j++){ $pref .= "xxx|";}
  open HANX,">$Basd/$Base.$lfrom.$i.add.gi" or die "$Pnam:\tCan't write \"$Basd/$Base.$lfrom.$i.add.gi\"";
  foreach my $gi (keys %gadd){ print HANX $gi."\n";}
  close HANX;
  $CMD = "blastdbcmd -db $db -entry_batch $Basd/$Base.$lfrom.$i.add.gi $target $long_seqids -out $Basd/$Base.$lfrom.$i.add.fa"; print STDERR "$Pnam:\t[ $CMD ]\n"; system $CMD;
  $CMD = "sr2fa $Basd/$Base.$lfrom.$i.sr -p= $pref > $Basd/$Base.$lfrom.$i.add.afa"; print STDERR "$Pnam:\t[ $CMD ]\n"; system $CMD;
  $CMD = "run_mafft_add $Basd/$Base.$lfrom.$i.add.fa -a= $Basd/$Base.$lfrom.$i.add.afa -w= $word -G=0.321 | fa2sr -w= $word > $Basd/$Base.$lfrom.$i.sr"; print STDERR "$Pnam:\t[ $CMD ]\n"; system $CMD;
 }
 unlink <$Basd/$Base.$lfrom.*.add.*> unless($DEBUG);
}

#---	special rules --------------------------------------
my @nlst = ();
if($alimode>0 and $lfrom==1){
 for(my $i=0;$i<$nt;$i++){
  $nlst[$i] = $glst[$i];
  $nlst[$i] =~ s/^.*\///;
  $nlst[$i] =~ s/\.[a-z]+$//;
 }
}

#---	rename results -------------------------------------
open HANX,">$Basd/$Base.sub.tab" or die "$Pnam:\tCan't write \"$Basd/$Base.sub.tab\"";
open HANY,">$name.cls" or die "$Pnam:\tCan't write \"$name.cls\"";
for(my $i=0;$i<$nt;$i++){
 my $n = $i + 1;
 my @gset = ();
 open HAND,"<$Basd/$Base.$lfrom.$n.sr" or die "$Pnam:\tCan't read \"$Basd/$Base.$lfrom.$n.sr\"";
 while(<HAND>){
  chomp;
  my ($gi) = split/\s+/;
  push @gset,$gi;
 }
 close HAND;
 my $nout = sprintf "%s.%d",$name,$n;
 if(@nlst>0){
  if($forcenew){
   #@@#$ CMD = "cp $Basd/$Base.$lfrom.$n.sr $nout.sr"; print STDERR "$Pnam:\t[ $CMD ]\n"; system $CMD;
  }
  $nout = $nlst[$i];
 }
 $CMD = "mv $Basd/$Base.$lfrom.$n.sr $nout.sr"; print STDERR "$Pnam:\t[ $CMD ]\n"; system $CMD;
 print HANX "$Base.$lfrom.$n\t$nout\n";
 printf HANY "%d %s\t%s\n",(scalar @gset),$nout,(join " ",@gset);
}
close HANY;
close HANX;
$CMD = "tree_ladder $Basd/$Base.$lfrom.up.tre | subs_keys $Basd/$Base.sub.tab -s=\"[(),:;]\" > $name.up.tre"; print STDERR "$Pnam:\t[ $CMD ]\n"; system $CMD;
if($hhsmode){
 $CMD = "cat $Basd/$Base.hhs.out | subs_keys $Basd/$Base.sub.tab -s=\"[\\s>]\" > $name.hhs.out"; print STDERR "$Pnam:\t[ $CMD ]\n"; system $CMD;
}

#---	clean ----------------------------------------------
unlink <$Basd/$Base.*> unless($DEBUG);
$CMD = "rm -r $Basd/"; print STDERR "$Pnam:\t[ $CMD ]\n"; system $CMD unless($DEBUG);

############################################################
#	template_function($xxxx)
############################################################
#sub template_function
#{
# my $xxxx = shift;
#}
